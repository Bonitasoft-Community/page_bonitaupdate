/* ==================================================
 * Noon/patch : Manage patch
 * ==================================================
 *
 * Creation 2006, by Imagina International
 *
 * This library is owned by Imagina International. You can't
 * redistribute it and/or modify it without the permission of
 * Imagina international
 *
 * -----------------------
 * NoPatch
 * -----------------------
 */
package com.imagina.noon.activities.patch;

// -----------------------------------------------------------------------------
/**
 * Imagina International
 * 
 * 
 * <H3> Description </H3>
 * Call the master to get the list of all patch. Compare it with the current list, then upload all missing patch
 * 
 * The current location of all files is found by studing the current classname
 * 
 * 
 * 
 * 
 * 
 * <H3> Use </H3>
 * Noon activity
 * 
 * <H3> Implementation </H3>
 * any information on the implementation, if necessary.
 * 
 * <H3> Change </H3>
 * 
 * and its historic, if necessary.
 * 
 * @author Imagina International
 * @created 15 juily 2003
 * @version 1.0
 */

// -----------------------------------------------------------------------------
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.net.Authenticator;
import java.net.HttpURLConnection;
import java.net.PasswordAuthentication;
import java.net.URL;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Properties;

import com.imagina.noon.activities.form.NoFormDescription;
import com.imagina.noon.engine.NoonActivity;
import com.imagina.noon.engine.NoonContext;
import com.imagina.noon.engine.NoonStatusExecution;
import com.imagina.noon.engine.NoonTankVariable;
import com.imagina.noon.engine.NoonVariableDef;
import com.imagina.noon.engine.NoonVariableDefInput;
import com.imagina.noon.engine.NoonVariableDefOutput;
import com.imagina.packbox.field.FieldDescription;
import com.imagina.packbox.file.FileTool;
import com.imagina.packbox.logger.LoggerLevel;
import com.imagina.packbox.logger.LoggerMessage;
import com.imagina.sobek.engine.SobekEngine;

// -------------------------------------------------
public class NoPatchDownloadNewPatch extends NoonActivity
{

  public static class SimpleAuthenticator extends Authenticator
  {
    private String username, password;

    public SimpleAuthenticator(String username, String password)
    {
      this.username = username;
      this.password = password;
    }

    protected PasswordAuthentication getPasswordAuthentication()
    {
      return new PasswordAuthentication(username, password == null ? null : password.toCharArray());
    }
  }

  public NoPatchDownloadNewPatch()
  {
    super();
  }

  // ---------------------------------------------------------------------------
  /**
   * getExplanation
   * 
   * @return a human readeable to explain the usage.
   */
  public String getExplanation()
  {
    return "Install the patch";
  }

  // ---------------------------------------------------------------------------
  /**
   * getInputVariableDescription
   * 
   * @return a set of variable expected at input of the activity.
   */
  public NoonVariableDefInput[] getInputVariablesDescription()
  {
    NoonVariableDefInput[] v = new NoonVariableDefInput[]
    {
        new NoonVariableDefInput(NoPatchDictionary.cstTankUrlMaster, false, // shared
                                 false, // not mandatory at init time
                                 NoonVariableDef.Properties.cstMandatory,
                                 null, // default value
                                 String.class,
                                 "Type of list"),
        new NoonVariableDefInput(NoPatchDictionary.cstTankVersionName, false, // shared
                                 false, // not mandatory at init
                                 // time
                                 NoonVariableDef.Properties.cstMandatory,
                                 null, // default value
                                 String.class,
                                 "name of the version"),
        new NoonVariableDefInput(NoPatchDictionary.cstTankSourcePath, false, // shared
                                 false, // not mandatory at init time
                                 NoonVariableDef.Properties.cstMandatory,
                                 null, // default value
                                 String.class,
                                 "Source path where patch file are"),
        new NoonVariableDefInput(NoPatchDictionary.cstTankSavePath, false, // shared
                                 false, // not mandatory at init time
                                 NoonVariableDef.Properties.cstMandatory,
                                 null, // default value
                                 String.class,
                                 "Destination to save patch to unistall them"),

        new NoonVariableDefInput(NoPatchDictionary.cstTankUrlProxy, false, // shared
                                 false, // not mandatory at init time
                                 NoonVariableDef.Properties.cstOptional,
                                 null, // default value
                                 String.class,
                                 "UrlProxy"),
        new NoonVariableDefInput(NoPatchDictionary.cstTankUrlPort, false, // shared
                                 false, // not mandatory at init time
                                 NoonVariableDef.Properties.cstOptional,
                                 null, // default value
                                 String.class,
                                 "proxy port"),
        new NoonVariableDefInput(NoPatchDictionary.cstTankUrlProxyUserName, false, // shared
                                 false, // not mandatory at init time
                                 NoonVariableDef.Properties.cstOptional,
                                 null, // default value
                                 String.class,
                                 "User name is authentication required"),
        new NoonVariableDefInput(NoPatchDictionary.cstTankUrlProxyPassword, false, // shared
                                 false, // not mandatory at init time
                                 NoonVariableDef.Properties.cstOptional,
                                 null, // default value
                                 String.class,
                                 "password is authentication requires")

    };

    return v;

  }

  // ---------------------------------------------------------------------------
  /**
   * getOutputVariableDescription
   * 
   * @return a set of variable expected at output of the activity.
   */
  public NoonVariableDefOutput[] getOutputVariablesDescription()
  {
    NoonVariableDefOutput[] v = new NoonVariableDefOutput[]
    {
        new NoonVariableDefOutput(NoPatchDictionary.cstTankListPatchHtml,
                                  NoonVariableDef.Properties.cstMandatory,
                                  String.class,
                                  "List of patch under HTML form"),
        new NoonVariableDefOutput(NoPatchDictionary.cstTankStatus, NoonVariableDef.Properties.cstMandatory, String.class, "Status")
    };

    return v;
  }

  // ---------------------------------------------------------------------------
  /**
   * getErrorExplanation
   * 
   * @return a human readeable explanation when the activity return an
   *         activityError status or return NULL if the activity doesn't have
   *         an activityError status.
   */
  public String getErrorExplanation()
  {
    return "An error arrive during the Installation";
  }

  // ---------------------------------------------------------------------------
  /**
   * initialisation of the activity. The Init object is given to access init
   * parameters.
   * 
   * @param initCtx
   *          the initialisation context
   * @param initVariable
   *          the list of intialisation variable.
   * @param theLog
   *          the log object
   * @return a NoonStatus (Ok, ERROR if initialisation failed)
   */
  public NoonStatusExecution init(NoonTankVariable initTank,
                                  NoonContext initCtx,
                                  LoggerMessage theLog)
  {
    return NoonStatusExecution.Correct;
  }

  // ---------------------------------------------------------------------------
  /**
   * execute the activity. this method is a multi thread save one.
   * 
   * @param ctx
   *          the context
   * @param tank
   *          the dictionary of parameters
   * @param theLog
   *          the log object
   * @return a NoonStatusExecution (Ok, ERROR... if execute failed during run)
   * @since
   */
  public NoonStatusExecution execute(NoonTankVariable tank,
                                     NoonContext ctx,
                                     LoggerMessage theLog)
  {
    String versionName = tank.getString(NoPatchDictionary.cstTankVersionName, theLog);
    String patchSourcePath = tank.getString(NoPatchDictionary.cstTankSourcePath, theLog);
    String patchSavePath = tank.getString(NoPatchDictionary.cstTankSavePath, theLog);
    String urlMaster = tank.getString(NoPatchDictionary.cstTankUrlMaster, theLog);
    String urlProxy = tank.getString(NoPatchDictionary.cstTankUrlProxy, theLog);
    String urlPort = tank.getString(NoPatchDictionary.cstTankUrlPort, theLog);

    String urlUserName = tank.getString(NoPatchDictionary.cstTankUrlProxyUserName, theLog);
    String urlPassword = tank.getString(NoPatchDictionary.cstTankUrlProxyPassword, theLog);

    //urlUserName = "BTEALLA";
    //urlPassword="";

    versionName = versionName.replace('\n', ' ');
    versionName = versionName.trim();

    ResultDownload result = downloadNewPath(versionName,
                                            patchSourcePath,
                                            patchSavePath,
                                            urlMaster,
                                            urlProxy,
                                            urlPort,
                                            urlUserName,
                                            urlPassword,
                                            theLog,
                                            this);

    tank.set(NoPatchDictionary.cstTankStatus, result.mStatusIsOk ? "OK" : "FAIL", theLog);
    tank.set(NoPatchDictionary.cstTankListPatchHtml, result.mDetail, theLog);

    if (result.mStatusIsOk)
      return NoonStatusExecution.Correct;
    return NoonStatusExecution.Error;
  }

  /**
   * 
   * @author pym
   *
   */
  protected static class ResultDownload
  {
    public boolean mStatusIsOk;
    public String  mDetail;
  }
  protected static ResultDownload downloadNewPath(String versionName,
                                                  String patchSourcePath,
                                                  String patchSavePath,
                                                  String urlMaster,
                                                  String urlProxy,
                                                  String urlPort,
                                                  String urlUserName,
                                                  String urlPassword,
                                                  LoggerMessage theLog,
                                                  Object caller)
  {
    ResultDownload resultDownload = new ResultDownload();

    ArrayList<String> listInSourcePath = FileTool.getListInDirectory(patchSourcePath + versionName, ".zip", true, theLog, caller);
    ArrayList<String> listInArchivePath = FileTool.getListInDirectory(patchSavePath + versionName, ".zip", true, theLog, caller);
    if (listInSourcePath == null || listInArchivePath == null)
    {
      resultDownload.mDetail = "Path source[" + patchSourcePath + versionName + "] or archive[" + patchSavePath + versionName + "] unknow";
      resultDownload.mStatusIsOk = false;
      return resultDownload;
    }

    HashMap<String, Object> listInPatch = new HashMap<String, Object>();

    for (String f : listInSourcePath)
      listInPatch.put(f, null);
    for (String f : listInArchivePath)
    {
      if (!f.startsWith(NoPatchDictionary.cstUninstall))
      {
        listInPatch.put(f, null);
      }
    }

    // Next, it must register the authenticator through Authenticator.setDefault(). If we adapt the previous code sample to use Authenticator, it looks like this:

    /* String url = "http://www.marchal.com/",
     proxy = "proxy.mydomain.com",
     port = "8080",
     username = "usr",
     password = "pwd";
     */
    if (urlUserName != null && urlUserName.length() > 0)
      Authenticator.setDefault(new SimpleAuthenticator(urlUserName, urlPassword));

    // get the list in the master now
    String traceLog = "";
    try
    {
      traceLog = "Connect["
          + urlMaster
          + "&"
          + SobekEngine.cstUrlStarterId
          + "=listsystem"
          + "&"
          + NoPatchDictionary.cstTankVersionName
          + "="
          + versionName
          + "]";
      URL url = new URL(urlMaster
          + "&"
          + SobekEngine.cstUrlStarterId
          + "=listsystem"
          + "&"
          + NoPatchDictionary.cstTankVersionName
          + "="
          + versionName);
      Properties systemProperties = System.getProperties();
      if (urlProxy != null && urlProxy.length() > 0)
        systemProperties.setProperty("http.proxyHost", urlProxy);
      if (urlPort != null && urlPort.length() > 0)
        systemProperties.setProperty("http.proxyPort", urlPort);

      // open the connexion
      HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();
      traceLog += ";Connection Correct, getInputStream";
      theLog.log(caller, LoggerLevel.Debug, "get the HTML content");
      InputStream input = urlConnection.getInputStream();
      traceLog += ";InputStream accessed, readIt";

      // read the stream
      byte[] buffer = new byte[ 5000 ];
      ByteArrayOutputStream byteOutput = new ByteArrayOutputStream();
      int totalRead = 0;
      int nbLus = input.read(buffer, 0, buffer.length);
      while (nbLus > 0)
      {
        totalRead += nbLus;
        byteOutput.write(buffer, 0, nbLus);
        nbLus = input.read(buffer, 0, buffer.length);
      }
      traceLog += ";inputStream read [" + totalRead + "], disconnect";

      input.close();
      String resultsString = byteOutput.toString();
      byteOutput.close();
      urlConnection.disconnect();
      traceLog += ";disconnected";

      // ---------------------- then study the result to get the <table>
      // content
      FieldDescription.StylesHtml styles = NoFormDescription.getHtmlStyle();

      String resultOperation = "<table class=\"" + styles.mListTable + "\">";
      resultOperation += "<tr class=\"" + styles.mListTableHeader + "\"><td>Name</td><td>Status</td>";
      boolean header = true;
      int pos = 0;
      while (pos != -1)
      {
        pos = resultsString.indexOf("<tr", pos);
        if (pos == -1)
          break;
        // get the first <td>
        int posTd = resultsString.indexOf("<td>", pos);
        if (posTd == -1)
          break;
        pos += 5; // go over the tr
        int posEndTd = resultsString.indexOf("</td>", posTd);
        if (posEndTd == -1)
          break;
        if (header)
        {
          header = false;
          continue;
        }

        String name = resultsString.substring(posTd + 4, posEndTd);

        if (listInPatch.containsKey(name + ".zip"))
        {
          theLog.log(caller, LoggerLevel.Info, "Master has patch[" + name + "], already downloaded");
          continue;
        }
        //---------------------------- dowload the patch !
        theLog.log(caller, LoggerLevel.Info, "Master has patch[" + name + "], download it");

        boolean status = downloadPatch(patchSourcePath, name, versionName, urlMaster, theLog, caller);
        resultOperation += "<tr class=\""
            + styles.mListTableLine1
            + "\"><td>"
            + name
            + "</td><td>"
            + (status ? "Downloaded" : "Failed")
            + "</td></tr>";

      }
      resultOperation += "</table>";
      resultDownload.mDetail = resultOperation;
      resultDownload.mStatusIsOk = true;

      return resultDownload;
    }
    catch (Exception e)
    {
      theLog.log(caller, "during uploadpatch [" + traceLog + "]", e);
      resultDownload.mDetail = e.toString() + " " + traceLog;
    }
    resultDownload.mStatusIsOk = false;
    return resultDownload;
  }

  /**
   * 
   * @param patchSavePath
   * @param patchName
   * @param versionName
   * @param urlMaster
   * @param theLog
   * @return
   */
  private static boolean downloadPatch(String patchPath,
                                       String patchName,
                                       String versionName,
                                       String urlMaster,
                                       LoggerMessage theLog,
                                       Object caller)
  {
    try
    {
      URL url = new URL(urlMaster
          + "&"
          + SobekEngine.cstUrlStarterId
          + "=downloadpatch"
          + "&"
          + NoPatchDictionary.cstTankVersionName
          + "="
          + versionName
          + "&"
          + NoPatchDictionary.cstTankPatchName
          + "="
          + patchName);

      // open the connexion
      HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();
      InputStream input = urlConnection.getInputStream();

      // read the stream
      byte[] buffer = new byte[ 5000 ];

      ByteArrayOutputStream byteOutput = new ByteArrayOutputStream();
      int nbLus = input.read(buffer, 0, buffer.length);
      while (nbLus > 0)
      {
        byteOutput.write(buffer, 0, nbLus);
        nbLus = input.read(buffer, 0, buffer.length);
      }
      input.close();
      byteOutput.close();

      // save as file
      FileOutputStream patchFile = new FileOutputStream(patchPath + File.separator + versionName + File.separator + patchName + ".zip");
      patchFile.write(byteOutput.toByteArray());
      patchFile.close();
      urlConnection.disconnect();
      return true;
    }
    catch (Exception e)
    {
      theLog.log(caller, "download patch", e);
      return false;
    }

  }
}
