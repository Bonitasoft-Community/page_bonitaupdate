/* ==================================================
 * Noon/patch : Manage patch
 * ==================================================
 *
 * Creation 2006, by Imagina International
 *
 * This library is owned by Imagina International. You can't
 * redistribute it and/or modify it without the permission of
 * Imagina international
 *
 * -----------------------
 * NoPatch
 * -----------------------
 */

package com.imagina.noon.activities.patch;

//-----------------------------------------------------------------------------
/**
 *                Imagina International
 *
 *
 *  <H3> Description </H3>
 *  Install a patch. 
 *  Study file inside the zip file, then save the current files on the UNINSTALL<patch> file
 *  Then, install the current file.
 *  Patch file are then move to the installed path
 *  At input, activity needs :
 *  - the patch to install ( a zip file)
 *  - the path where source pach is located
 *  - the path to save the UNINSTALL file. zip file will be moved to this path
 *  
 *  The current location of all files is found by studing the current classname
 *  
 *  

 *   
 *   
 *  <H3> Use </H3>
 *  Noon activity
 *
 *  <H3> Implementation </H3>
 *  any information on the implementation, if necessary.
 *
 *  <H3> Change </H3>
 *
 *  and its historic, if necessary.
 *
 * @author     Imagina International
 * @created    15 juily 2003
 * @version    1.0
 */

//-----------------------------------------------------------------------------
import java.io.File;
import java.util.ArrayList;
import java.util.Collections;

import com.imagina.noon.activities.admin.NoAdminClearCache;
import com.imagina.noon.activities.form.NoFormDescription;
import com.imagina.noon.activities.patch.NoPatchList.PatchComparator;
import com.imagina.noon.activities.toolbox.NoToolboxZip;
import com.imagina.noon.engine.NoonActivity;
import com.imagina.noon.engine.NoonContext;
import com.imagina.noon.engine.NoonStatusExecution;
import com.imagina.noon.engine.NoonTankVariable;
import com.imagina.noon.engine.NoonVariableDef;
import com.imagina.noon.engine.NoonVariableDefInput;
import com.imagina.noon.engine.NoonVariableDefOutput;
import com.imagina.packbox.field.FieldDescription;
import com.imagina.packbox.file.FileTool;
import com.imagina.packbox.logger.LoggerEvent;
import com.imagina.packbox.logger.LoggerMessage;

//-------------------------------------------------
public class NoPatchInstallPatch extends NoonActivity
{

  public NoPatchInstallPatch()
  {
    super();
  }

  // ---------------------------------------------------------------------------
  /**
   * getExplanation
   * @return a human readeable to explain the usage.
   */
  @Override
  public String getExplanation()
  {
    return "Install the patch";
  }
  // ---------------------------------------------------------------------------
  /**
   * getInputVariableDescription
   *
   * @return a set of variable expected at input of the activity.
   */
  @Override
  public NoonVariableDefInput[] getInputVariablesDescription()
  {
    NoonVariableDefInput[] v = new NoonVariableDefInput[]
    {
        new NoonVariableDefInput(NoPatchDictionary.cstTankPatchFile, false, // shared
                                 false, // not mandatory at init time
                                 NoonVariableDef.Properties.cstOptional,
                                 null, // default value
                                 String.class,
                                 "Name of the Zip variable. If null, all patch present in the source directory will be installed"),
        new NoonVariableDefInput(NoPatchDictionary.cstTankVersionName, false, // shared
                                 false, // not mandatory at init time
                                 NoonVariableDef.Properties.cstMandatory,
                                 null, // default value
                                 String.class,
                                 "name of the version"),
        new NoonVariableDefInput(NoPatchDictionary.cstTankSourcePath, false, // shared
                                 false, // not mandatory at init time
                                 NoonVariableDef.Properties.cstMandatory,
                                 null, // default value
                                 String.class,
                                 "Source path where patch file are"),
        new NoonVariableDefInput(NoPatchDictionary.cstTankSavePath, false, // shared
                                 false, // not mandatory at init time
                                 NoonVariableDef.Properties.cstMandatory,
                                 null, // default value
                                 String.class,
                                 "Destination to save patch to unistall them")
    };

    return v;

  }
  // ---------------------------------------------------------------------------
  /**
   * getOutputVariableDescription
   *
   * @return a set of variable expected at output of the activity.
   */
  @Override
  public NoonVariableDefOutput[] getOutputVariablesDescription()
  {
    NoonVariableDefOutput[] v = new NoonVariableDefOutput[]
    {
      new NoonVariableDefOutput(NoPatchDictionary.cstTankStatus, NoonVariableDef.Properties.cstMandatory, String.class, "Status")
    };

    return v;
  }

  // ---------------------------------------------------------------------------
  /**
   * getErrorExplanation
   *
   * @return a human readeable explanation when the activity return an activityError
   * status or return NULL if the activity doesn't have an activityError status.
   */
  @Override
  public String getErrorExplanation()
  {
    return "An error arrive during the Installation";
  }

  // ---------------------------------------------------------------------------
  /**
   *  initialisation of the activity. The Init object is given to access init
   *  parameters.
   *
   *@param  initCtx            the initialisation context
   *@param  initVariable  	the list of intialisation variable.
   *@param  theLog             the log object
   *@return                     a NoonStatus (Ok, ERROR if initialisation failed)
   */
  @Override
  public NoonStatusExecution init(NoonTankVariable initTank,
                                  NoonContext initCtx,
                                  LoggerMessage theLog)
  {

    return NoonStatusExecution.Correct;
  }

  // ---------------------------------------------------------------------------
  /**
   * execute the activity.
   * this method is a multi thread save one.
   *@param  ctx     the context
   *@param  tank    the dictionary of parameters
   *@param  theLog  the log object
   *@return         a NoonStatusExecution (Ok, ERROR... if execute failed during run)
   *@since
   */
  @Override
  public NoonStatusExecution execute(NoonTankVariable tank,
                                     NoonContext ctx,
                                     LoggerMessage theLog)
  {
    String patchFile = tank.getString(NoPatchDictionary.cstTankPatchFile, theLog);
    String versionName = tank.getString(NoPatchDictionary.cstTankVersionName, theLog);
    String patchSourcePath = tank.getString(NoPatchDictionary.cstTankSourcePath, theLog);
    String patchSavePath = tank.getString(NoPatchDictionary.cstTankSavePath, theLog);
    // FileTool fileTool = new FileTool();

    //String rootPath = fileTool.getRootSourcePath(theLog);
    String rootPath = ctx.getConfig().getInstancePath();
    versionName = versionName.replace('\n', ' ');
    versionName = versionName.trim();

    ResultInstall result = installPatch(versionName, patchFile, patchSourcePath, patchSavePath, rootPath, ctx, theLog, this);

    tank.set(NoPatchDictionary.cstTankStatus, result.mDetail, theLog);

    if (result.mStatusIsOk)
      return NoonStatusExecution.Correct;
    return NoonStatusExecution.Error;

  }

  /**
   * 
   */
  public static class ResultInstall
  {
    public boolean mStatusIsOk;
    public String  mDetail;
  }
  public static ResultInstall installPatch(String versionName,
                                           String patchFile,
                                           String patchSourcePath,
                                           String patchSavePath,
                                           String rootPath,
                                           NoonContext ctx,
                                           LoggerMessage theLog,
                                           Object caller)
  {
    ArrayList<String> listInPath = null;
    ResultInstall resultInstall = new ResultInstall();

    if (patchFile == null)
    {
      listInPath = FileTool.getListInDirectory(patchSourcePath + versionName, ".zip", true, theLog, caller);
      if (listInPath == null)
      {

        String resultString = "<table><tr><td>";
        resultString += "No path [" + patchSourcePath + versionName + "] exist";
        resultString += "</td></tr></table>";
        resultInstall.mDetail = resultString;
        resultInstall.mStatusIsOk = true;
        return resultInstall;

      }
      // order the list
      Collections.sort(listInPath, new PatchComparator());
    }
    else
    {
      listInPath = new ArrayList<String>();
      listInPath.add(patchFile);
    }

    ArrayList<LoggerEvent> resultInstallation = new ArrayList<LoggerEvent>();
    for (String f : listInPath)
    {
      // get the content of patchfile
      ArrayList<NoToolboxZip.ZipItem> listOfEntry = NoToolboxZip.getContentPatch(patchSourcePath + versionName + File.separator + f, theLog, caller);

      // then save the list of file under the Save File
      for (NoToolboxZip.ZipItem zipItem : listOfEntry)
      {
        zipItem.mInput = null; // clear the item to force to save the fileName
      }
      boolean status = NoPatchToolbox.createZipFile(rootPath, listOfEntry, patchSavePath
          + versionName
          + File.separator
          + NoPatchDictionary.cstUninstall
          + f, true, theLog, caller);
      if (!status)
      {
        resultInstallation.add(new LoggerEvent(NoPatchEvent.cstErrorDuringSaveUninstall, f));
        continue;
      }
      // then install the current files
      String statusSt = NoPatchToolbox.installPatch(f, patchSourcePath + versionName + File.separator + f, rootPath,null, theLog, caller);
      if (statusSt != null)
      {
        resultInstallation.add(new LoggerEvent(NoPatchEvent.cstErrorDuringInstall, f + "/" + statusSt));
        statusSt = NoPatchToolbox.installPatch(f,
                                              patchSavePath + versionName + File.separator + NoPatchDictionary.cstUninstall + f,
                                              rootPath,
                                              null,
                                              theLog,
                                              caller);
        if (statusSt != null)
        {
          resultInstallation.add(new LoggerEvent(NoPatchEvent.cstErrorDuringRollbackinstall, f + "/" + statusSt));
        }
        continue;

      }

      // then move the patch file from the install to the uninstall patch
      status = FileTool.moveFile(patchSourcePath + versionName + File.separator + f, patchSavePath + versionName + File.separator + f, theLog, caller);
      if (!status)
      {
        resultInstallation.add(new LoggerEvent(NoPatchEvent.cstErrorDuringArchivePathFile, f));
        continue;
      }

      resultInstallation.add(new LoggerEvent(NoPatchEvent.cstPatchInstalled, f));

      // then now install the patch
    }

    NoAdminClearCache.clearSqlForeignLabelCache(ctx, theLog);
    NoAdminClearCache.clearCache(ctx, theLog);

    FieldDescription.StylesHtml styles = NoFormDescription.getHtmlStyle();

    String resultString = "<table>";
    for (LoggerEvent event : resultInstallation)
    {
      resultString += "<tr><td>"
          + event.getHtml(styles.mExplanationTitle, styles.mExplanationError, false, ctx.getTranslation(), ctx.getLanguageId(), theLog)
          + "</td></tr>";
    }
    resultString += "</table>";

    resultInstall.mDetail = resultString;
    resultInstall.mStatusIsOk = true;
    return resultInstall;

  }
}
